<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为什么三种基本程序结构可以实现所有的算法</title>
    <link href="/2021/03/18/Some%20Interesting%20Questions%20About%20CS/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/18/Some%20Interesting%20Questions%20About%20CS/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么三种基本程序结构可以实现所有的算法"><a href="#为什么三种基本程序结构可以实现所有的算法" class="headerlink" title="为什么三种基本程序结构可以实现所有的算法"></a>为什么三种基本程序结构可以实现所有的算法</h1><p>在学习软件工程相关的知识时，有这样一句话：</p><blockquote><p>按照结构化程序设计的观点,任何算法功能都可以通过由程序模块组成的三种基本程序结构的组合:顺序结构、选择结构和循环结构来实现。</p></blockquote><p>那么为什么说”三种基本的程序结构的组合就可以实现任何的算法功能“呢？这句话乍看上去感觉应该是对的，在过去的编程实践中我们的确是可以使用顺序结构、分支结构、循环结构是满足我们各种场景下的程序设计需求，但是我们无法从理论上确保：”任何”算法都能由这三种结构描述。这种疑惑实际上是有些显得幼稚的，就像“太阳为什么每天东升西落”一样，太显然的常识似乎不必追问。但问题就是在那，若是给不出一个清澈的解答，那它就是在那，一直在那。于是关于此问题，我做了一些网络搜索工作，在此做一下相关的总结。</p><hr><h2 id="一、先引点没用的东西，GOTO语句的害处"><a href="#一、先引点没用的东西，GOTO语句的害处" class="headerlink" title="一、先引点没用的东西，GOTO语句的害处"></a>一、先引点没用的东西，GOTO语句的害处</h2><p>首先引一点没用的东西，这个问题的缘起应该就是“不建议在程序设计中使用GOTO的倡议”，先辈们建议“仅使用三种程序结构设计程序”，一条基本依据便是“仅使用三种基本程序结构就可以实现所有算法”。其他还有诸多重要的依据，譬如有助于提升程序的可阅读性、可维护性、安全性等等，这些便不在下文进一步展开。</p><blockquote><p>这里引用了Dijkstra的一篇文章，主要讲了在程序中使用“GOTO”语句的害处。<br>原文地址：<a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html</a></p></blockquote><h4 id="Go-To-Statement-Considered-Harmful"><a href="#Go-To-Statement-Considered-Harmful" class="headerlink" title="Go To Statement Considered Harmful"></a>Go To Statement Considered Harmful</h4><p>Edsger W. Dijkstra</p><hr><p>Reprinted from Communications of the ACM, Vol. 11, No. 3, March 1968, pp. 147-148. Copyright © 1968, Association for Computing Machinery, Inc.<br>This is a digitized copy derived from an ACM copyrighted work. It is not guaranteed to be an accurate copy of the author’s original work.</p><hr><h4 id="Key-Words-and-Phrases"><a href="#Key-Words-and-Phrases" class="headerlink" title="Key Words and Phrases:"></a>Key Words and Phrases:</h4><p><strong>go to</strong> statement, jump instruction, branch instruction, conditional clause, alternative clause, repetitive clause, program intelligibility, program sequencing<br>CR Categories:<br>4.22, 6.23, 5.24</p><h4 id="Editor"><a href="#Editor" class="headerlink" title="Editor:"></a>Editor:</h4><p>For a number of years I have been familiar with the observation that the quality of programmers is a decreasing function of the density of <strong>go to</strong> statements in the programs they produce. More recently I discovered why the use of the <strong>go to</strong> statement has such disastrous effects, and I became convinced that the <strong>go to</strong> statement should be abolished from all “higher level” programming languages (i.e. everything except, perhaps, plain machine code). At that time I did not attach too much importance to this discovery; I now submit my considerations for publication because in very recent discussions in which the subject turned up, I have been urged to do so.<br>My first remark is that, although the programmer’s activity ends when he has constructed a correct program, the process taking place under control of his program is the true subject matter of his activity, for it is this process that has to accomplish the desired effect; it is this process that in its dynamic behavior has to satisfy the desired specifications. Yet, once the program has been made, the “making’ of the corresponding process is delegated to the machine.</p><p>My second remark is that our intellectual powers are rather geared to master static relations and that our powers to visualize processes evolving in time are relatively poorly developed. For that reason we should do (as wise programmers aware of our limitations) our utmost to shorten the conceptual gap between the static program and the dynamic process, to make the correspondence between the program (spread out in text space) and the process (spread out in time) as trivial as possible.</p><p>Let us now consider how we can characterize the progress of a process. (You may think about this question in a very concrete manner: suppose that a process, considered as a time succession of actions, is stopped after an arbitrary action, what data do we have to fix in order that we can redo the process until the very same point?) If the program text is a pure concatenation of, say, assignment statements (for the purpose of this discussion regarded as the descriptions of single actions) it is sufficient to point in the program text to a point between two successive action descriptions. (In the absence of <strong>go to</strong> statements I can permit myself the syntactic ambiguity in the last three words of the previous sentence: if we parse them as “successive (action descriptions)” we mean successive in text space; if we parse as “(successive action) descriptions” we mean successive in time.) Let us call such a pointer to a suitable place in the text a “textual index.”</p><p>When we include conditional clauses (if B then A), alternative clauses (if B then A1 else A2), choice clauses as introduced by C. A. R. Hoare (case[i] of (A1, A2,···, An)),or conditional expressions as introduced by J. McCarthy (B1 -&gt; E1, B2 -&gt; E2, ···, Bn -&gt; En), the fact remains that the progress of the process remains characterized by a single textual index.</p><p>As soon as we include in our language procedures we must admit that a single textual index is no longer sufficient. In the case that a textual index points to the interior of a procedure body the dynamic progress is only characterized when we also give to which call of the procedure we refer. With the inclusion of procedures we can characterize the progress of the process via a sequence of textual indices, the length of this sequence being equal to the dynamic depth of procedure calling.</p><p>Let us now consider repetition clauses (like, while B repeat A or repeat A until B). Logically speaking, such clauses are now superfluous, because we can express repetition with the aid of recursive procedures. For reasons of realism I don’t wish to exclude them: on the one hand, repetition clauses can be implemented quite comfortably with present day finite equipment; on the other hand, the reasoning pattern known as “induction” makes us well equipped to retain our intellectual grasp on the processes generated by repetition clauses. With the inclusion of the repetition clauses textual indices are no longer sufficient to describe the dynamic progress of the process. With each entry into a repetition clause, however, we can associate a so-called “dynamic index,” inexorably counting the ordinal number of the corresponding current repetition. As repetition clauses (just as procedure calls) may be applied nestedly, we find that now the progress of the process can always be uniquely characterized by a (mixed) sequence of textual and/or dynamic indices.</p><p>The main point is that the values of these indices are outside programmer’s control; they are generated (either by the write-up of his program or by the dynamic evolution of the process) whether he wishes or not. They provide independent coordinates in which to describe the progress of the process.</p><p>Why do we need such independent coordinates? The reason is - and this seems to be inherent to sequential processes - that we can interpret the value of a variable only with respect to the progress of the process. If we wish to count the number, n say, of people in an initially empty room, we can achieve this by increasing n by one whenever we see someone entering the room. In the in-between moment that we have observed someone entering the room but have not yet performed the subsequent increase of n, its value equals the number of people in the room minus one!</p><p>The unbridled use of the <strong>go to</strong> statement has an immediate consequence that it becomes terribly hard to find a meaningful set of coordinates in which to describe the process progress. Usually, people take into account as well the values of some well chosen variables, but this is out of the question because it is relative to the progress that the meaning of these values is to be understood! With the <strong>go to</strong> statement one can, of course, still describe the progress uniquely by a counter counting the number of actions performed since program start (viz. a kind of normalized clock). The difficulty is that such a coordinate, although unique, is utterly unhelpful. In such a coordinate system it becomes an extremely complicated affair to define all those points of progress where, say, n equals the number of persons in the room minus one!</p><p>The <strong>go to</strong> statement as it stands is just too primitive; it is too much an invitation to make a mess of one’s program. One can regard and appreciate the clauses considered as bridling its use. I do not claim that the clauses mentioned are exhaustive in the sense that they will satisfy all needs, but whatever clauses are suggested (e.g. abortion clauses) they should satisfy the requirement that a programmer independent coordinate system can be maintained to describe the process in a helpful and manageable way.</p><p>It is hard to end this with a fair acknowledgment. Am I to judge by whom my thinking has been influenced? It is fairly obvious that I am not uninfluenced by Peter Landin and Christopher Strachey. Finally I should like to record (as I remember it quite distinctly) how Heinz Zemanek at the pre-ALGOL meeting in early 1959 in Copenhagen quite explicitly expressed his doubts whether the <strong>go to</strong> statement should be treated on equal syntactic footing with the assignment statement. To a modest extent I blame myself for not having then drawn the consequences of his remark</p><p>The remark about the undesirability of the <strong>go to</strong> statement is far from new. I remember having read the explicit recommendation to restrict the use of the <strong>go to</strong> statement to alarm exits, but I have not been able to trace it; presumably, it has been made by C. A. R. Hoare. In [1, Sec. 3.2.1.] Wirth and Hoare together make a remark in the same direction in motivating the case construction: “Like the conditional, it mirrors the dynamic structure of a program more clearly than <strong>go to</strong> statements and switches, and it eliminates the need for introducing a large number of labels in the program.”</p><p>In [2] Guiseppe Jacopini seems to have proved the (logical) superfluousness of the <strong>go to</strong> statement. The exercise to translate an arbitrary flow diagram more or less mechanically into a jump-less one, however, is not to be recommended. Then the resulting flow diagram cannot be expected to be more transparent than the original one.</p><h4 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h4><p>Wirth, Niklaus, and Hoare C. A. R. A contribution to the development of ALGOL. Comm. ACM 9 (June 1966), 413-432.<br>BÖhm, Corrado, and Jacopini Guiseppe. Flow diagrams, Turing machines and languages with only two formation rules. Comm. ACM 9 (May 1966), 366-371.<br>Edsger W. Dijkstra<br>Technological University<br>Eindhoven, The Netherlands</p><hr><h2 id="二、认识问题"><a href="#二、认识问题" class="headerlink" title="二、认识问题"></a>二、认识问题</h2><p>解答问题的第一步应该是认识问题。现在的问题是“为什么三种基本程序结构可以实现所有的算法”，其中“三种基本程序结构”指的是“顺序程序结构、分支程序结构、循环程序结构”，这三个在长期的实践中可以有一个大概的认识。那么什么是“算法”呢？我记得教材上大概是这么说的：解决问题的步骤称作算法。</p><p>我们既然要回答“为什么三种基本程序结构可以实现所有的算法”，首先作出一个前置规定，即我已经明确了“三种基本程序结构”到底是什么，也就是给我一个程序，我必然能精准地判定其是否是由“三种基本程序结构”组合而成，这样一来，我便可以认为自己已经理解了该问题的前半部分了。那接下来就必然得先知道什么是“所有的算法”，如果不对“所有的算法”做一个明确的前置规定，那么不论接下来证明多少的东西，都将是不严谨的、狭隘的，因为我似乎不可能用有限的语言表达出无限的含义。</p><p>那么什么是“所有的算法”呢？那便需要明白“什么是算法”。所谓“明白”，大概可以理解成给定一个事物，可以精准地判定其是或者不是。那么关于“什么是算法”，仅考虑计算机领域，便可以更具体一点地问：“什么是计算机程序算法”。在了解了一些图灵机相关的计算理论之后，我<strong>认为</strong>计算机程序算法是“计算的过程”。那么什么是“计算的过程”，首先考虑“计算”，经我查阅了解，“图灵机”便是对“计算”做的一种形式化定义，即图灵机做的事情便是“计算”，我也十分愿意接受这个定义；而关于“过程”，我想大概可以理解为从计算的开始到计算的结束之间所发生的相关的每一步处理。原谅我无法给出“绝对”准确的描述，是的，我只能给一个大致的描述，这并不“绝对严谨”，我也不知道这世上有没有“绝对严谨”的存在。</p><blockquote><p>关于“计算”与“图灵机”，我是参考了这一篇文章，认为讲的还是比较清楚，可以理解的。仔细阅读后，便可以理解“为什么“图灵机”是对“计算”的一种定义”，以及“如何认识“计算”这个玩意”。<br>地址：<a href="https://zhuanlan.zhihu.com/p/20318904">https://zhuanlan.zhihu.com/p/20318904</a></p></blockquote><p>那到此为止，我们就明白了什么是“三种基本程序结构”、什么是”所有的算法”。</p><hr><h2 id="三、解决问题"><a href="#三、解决问题" class="headerlink" title="三、解决问题"></a>三、解决问题</h2><p>事实上，当对一个问题有了充分的认识之后，或者说对问题做了充分严谨的限定之后，问题的解决便成了一件“秋风扫落叶”般容易之事，很多问题都是如此。</p><p>前面已经说了（已经限定了），”计算”便是“图灵机”的工作，而“算法”便是“计算的过程”，若我们可以证明“三种基本程序结构”可以进行所有“图灵机”的工作，那便可以推导出“三种基本程序结构”可以实现“所有的算法”，那其实读完上面那篇文章之后，我们便知道只要我们可以实现“通用图灵机”的工作，我们可以实现“所有图灵机”的工作。我们的编程实践告诉我们这显然是一件可行的事，即我们完全可以用“三种基本程序结构”去模拟出“图灵机”的工作，因此使用“三种基本程序结构”必然可以实现所有的算法。</p><p>问题很轻易地就被回答了，这已经是非常准确的回答。但这个回答似乎有些畸形，并没有那种酷炫的式子推演证明等等，而仅仅是明确了一下“定义”，仅此而已。实际上，这个问题本身就是有些幼稚的，之所以会有这样的疑问，完全是出于对问题的认识肤浅（非贬义，仅仅是客观的肤浅）。事实上，“三种基本程序结构”与“所有算法的实现”根本不是一个层次的概念，前者已经是非常高度的抽象，因此这根本不是一个“数学意义”上的问题，而仅仅是一个概念上的问题，在概念梳理清楚之后，问题自然迎刃而解。</p>]]></content>
    
    
    <categories>
      
      <category>Some Interesting Questions About CS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>岳希航的markdown学习笔记（markdown格式测试）</title>
    <link href="/2021/03/12/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/%E5%B2%B3%E5%B8%8C%E8%88%AA%E7%9A%84markdown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/03/12/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/%E5%B2%B3%E5%B8%8C%E8%88%AA%E7%9A%84markdown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p>正文</p><p>==高亮==</p><p><strong>粗体</strong></p><p><u>下划线</u></p><p><del>删除线</del></p><p><a href="www.baidu.com">超链接</a></p><blockquote><p>引用。。<br> 。。。</p></blockquote><ul><li>列表1</li><li>列表2</li></ul><ul><li>列表1</li><li>列表2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/03/12/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/%E5%B2%B3%E5%B8%8C%E8%88%AA%E7%9A%84markdown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/timg.jpg"></p><p>$$<br>\geq<br>$$</p><p>$$<br>\leq<br>$$</p><p>$$</p><blockquote></blockquote><p>$$</p><p>$$<br>&lt;<br>$$</p><p>$$<br>yuexihang<br>$$</p><p>$$<br>a_1<br>$$</p><p>$$<br>a^2<br>$$</p><p>$$<br>a_1^2<br>$$</p><p>$$<br>a_{i,j}<br>$$</p><p>$$<br>a_{a_{a_1}}<br>$$</p><p>这个公式$x=1$</p><table><thead><tr><th>ID</th><th>姓名</th><th>性别</th></tr></thead><tbody><tr><td>grsgsrfae</td><td>faefaef</td><td>fafafa</td></tr><tr><td>fafaf</td><td>fafa</td><td>fafafa</td></tr><tr><td>fafaf</td><td>fafafa</td><td>fafafa</td></tr></tbody></table><hr><p>缩进</p>]]></content>
    
    
    <categories>
      
      <category>建站过程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>岳希航的hexo使用与搭建手册</title>
    <link href="/2021/03/12/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/%E5%B2%B3%E5%B8%8C%E8%88%AA%E7%9A%84hexo%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/"/>
    <url>/2021/03/12/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/%E5%B2%B3%E5%B8%8C%E8%88%AA%E7%9A%84hexo%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-Github-使用、搭建手册"><a href="#hexo-Github-使用、搭建手册" class="headerlink" title="hexo + Github 使用、搭建手册"></a>hexo + Github 使用、搭建手册</h1><h3 id="使用过程中的参考（日常维护参考）"><a href="#使用过程中的参考（日常维护参考）" class="headerlink" title="使用过程中的参考（日常维护参考）"></a>使用过程中的参考（日常维护参考）</h3><h4 id="常用命令与操作"><a href="#常用命令与操作" class="headerlink" title="常用命令与操作"></a>常用命令与操作</h4><p><code>hexo clean </code><br><code>hexo g </code><br><code>hexo s </code><br><code>hexo d </code></p><h6 id="修改文章标题"><a href="#修改文章标题" class="headerlink" title="修改文章标题"></a>修改文章标题</h6><p>修改front-matter中的title即可。</p><h6 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h6><p>直接删除文件即可。</p><h4 id="常用网址"><a href="#常用网址" class="headerlink" title="常用网址"></a>常用网址</h4><p>模板Fluid官网：<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a><br>Hexo官网：<a href="https://hexo.io/">https://hexo.io/</a></p><h3 id="搭建时我的参考手册（搭建过程）"><a href="#搭建时我的参考手册（搭建过程）" class="headerlink" title="搭建时我的参考手册（搭建过程）"></a>搭建时我的参考手册（搭建过程）</h3><h4 id="Hexo-Github搭建："><a href="#Hexo-Github搭建：" class="headerlink" title="Hexo+Github搭建："></a>Hexo+Github搭建：</h4><p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p><h4 id="Hexo的使用"><a href="#Hexo的使用" class="headerlink" title="Hexo的使用"></a>Hexo的使用</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/129245387">https://zhuanlan.zhihu.com/p/129245387</a></li><li><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li></ul><h4 id="个人域名绑定解决方案："><a href="#个人域名绑定解决方案：" class="headerlink" title="个人域名绑定解决方案："></a>个人域名绑定解决方案：</h4><p><a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#">https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#</a></p><p>注意：阿里云上的域名必须首先完成实名认证，虽然阿里云控制台里面ink域名没有显示必须实名认证（它上面列举了一些后缀称必须实名认证才可以使用，里面并没有ink域名），但我发现怎么都解析不成功，这浪费了我大量的时间，令人厌恶的阿里云。</p><p>若域名解析功能时正常的话，只需要按照官网的要求配置域名DNS的CNAME记录就可以了，不需要设置A记录。</p><h4 id="Hexo-与-typora搭配使用时的图片问题解决方案"><a href="#Hexo-与-typora搭配使用时的图片问题解决方案" class="headerlink" title="Hexo 与 typora搭配使用时的图片问题解决方案"></a>Hexo 与 typora搭配使用时的图片问题解决方案</h4><p><a href="https://www.jianshu.com/p/ea78bdd0551f/">https://www.jianshu.com/p/ea78bdd0551f/</a><br>这是一种最普遍的解决方案，另外一种解决方案是基于hexo-easy-assets插件。虽然这个方案看起来很简单，我也很早就找到了，但我一直没有实现，因为没有梯子工具，插件一直安装失败，而且我也一直没有理解其中的两步（设置config文件和安装插件分别的作用是什么），这导致我在图片问题的解决上花费了两三个小时的时间。</p><p>下面为测试图片：</p><p><img src="/2021/03/12/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/%E5%B2%B3%E5%B8%8C%E8%88%AA%E7%9A%84hexo%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/timg.jpg"></p><hr><p>折腾了一整天（几乎整整24个小时），终于把一些基本问题解决了。目前仍然存在一个问题，就是_posts文件下所有的文章都在一起，我无法按照一定的分类去安排文章的位置，目前我计划的解决方案便是仍然在外面的markdown笔记中写文章，需要上传到博客中时，将文件和对应的图片资源复制到_post文件夹下。</p><p>经过测试，我发现完全可以不使用 <code>hexo new &quot;标题&quot;</code> 命令来创建文章，自己手动创建相应的文章和资源文件夹（与文章标题同名）也是可以的。只是需要自己添加相应的front-matter部分。</p><hr><h4 id="Hexo-Fluid主题实现数学公式"><a href="#Hexo-Fluid主题实现数学公式" class="headerlink" title="Hexo + Fluid主题实现数学公式"></a>Hexo + Fluid主题实现数学公式</h4><p>参考fluid官方文档。</p><hr><p>经过艰苦奋斗，现在可以开始高效地建设blog了，无论是功能、界面还是内容。感觉就好像是建起来一座新房子，最后打扫打扫卫生，然后舒适地住下来~~。</p><p>显然感受到的是hexo这种类型的博客系统十分好用，我可以十分轻松的将自己的关注点放在内容上，因为添加内容非常方便，我只需要在需要开始写作时点击本地的软件即可，无论是直接在博客上编写还是首先在本地写好，在恰当的时候我可以通过几条简单的命令快速地将最新的内容渲染、上传，就像我现在正在做的这样，简易、快捷的将自己建站的过程记录下来，顺便还可以发表一些感悟。</p><p>另外有一个问题就是fluid模板中，文章页旁边的大纲栏似乎是有些bug的，有些同级标题都没有对齐。</p><hr><p>经过测试我发现，在_post文件夹下管理文章时，可以直接建立文件夹分类管理，在渲染称静态网页时，hexo会自动忽略该文件夹，这样一来管理本地存储的博客上的文章就更加舒适了，可以将一类的文章统一放在一个文件夹下存储。</p><p>而且，经过测试发现，二级文件夹、文件夹下文章的图片、二级文件夹下文章的图片、不同级别文件夹下的同名文章（文件名相同）都可以正确渲染。</p><p>唯一需要注意的便是，更低一级的“文件夹名称”莫要与上一级文章的图片资源文件夹名称撞了（也就是更低一级的分类莫要与上一级的文章名撞了），那样本地管理起来确实有点乱糟糟嘞。</p>]]></content>
    
    
    <categories>
      
      <category>建站过程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/03/11/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/hello-world/"/>
    <url>/2021/03/11/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>建站过程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
